{"version":3,"file":"js/994.f81b95bb.js","mappings":"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","sources":["webpack://dumpster-diving-ionic/./src/views/Tab2Page.vue","webpack://dumpster-diving-ionic/./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js","webpack://dumpster-diving-ionic/./src/views/SpotModal.vue","webpack://dumpster-diving-ionic/./src/stores/counter.js","webpack://dumpster-diving-ionic/./src/views/SpotModal.vue?f572","webpack://dumpster-diving-ionic/./src/views/Tab2Page.vue?d168"],"sourcesContent":["<template>\n  <ion-page>\n    <ion-header>\n      <!-- <ion-toolbar>\n        <ion-title>Map</ion-title>\n      </ion-toolbar> -->\n    </ion-header>\n    <ion-content :fullscreen=\"true\">\n      <ion-header collapse=\"condense\">\n        <ion-toolbar>\n          <ion-title size=\"large\">Tab 2</ion-title>\n        </ion-toolbar>\n      </ion-header>\n      <l-map \n        z-index=0\n        :zoom=\"13\" \n        :center=\"[50.9223,11.5723]\" \n        :options=\"{zoomControl: false}\">\n        <l-tile-layer style=\"z-index: 100\" url=\"https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png\"></l-tile-layer>\n          <l-marker \n            @click=\"openModal(marker.id)\"\n            v-for=\"(marker, index) in markers\"\n            :key=\"index\"\n            ref=\"markersRef\"\n            :lat-lng=\"marker.coord\"\n            >\n          </l-marker>\n      </l-map>\n    </ion-content>\n  </ion-page>\n</template>\n\n<script>\nimport { defineComponent } from 'vue';\nimport { IonPage, IonHeader, IonToolbar, IonTitle, IonContent } from '@ionic/vue';\nimport \"leaflet/dist/leaflet.css\"\nimport { LMap, LTileLayer, LMarker } from \"@vue-leaflet/vue-leaflet\";\nimport { supabase } from \"@/supabase\"\nimport { modalController } from '@ionic/vue';\nimport Modal from './SpotModal.vue';\nimport { useCounterStore } from '@/stores/counter'\n\nexport default defineComponent({\n  name: 'Tab2Page',\n  components: { \n    IonHeader, \n    IonToolbar, \n    IonTitle, \n    IonContent, \n    IonPage, \n    LMap,\n    LTileLayer,\n    LMarker,\n    },\n  setup() {\n  },\n  async created() {\n    const {data: events} = await supabase\n      .from('events')\n      .select('coordinates,id')\n    this.populate_markers_array(events)\n    this.loaded = true\n  },\n  data: () => ({\n    spot: false,\n    zoomControl: false,\n    loaded: true,\n    markers: [],\n  }),\n  methods: {\n    populate_markers_array: function (marker_objects) {\n      this.markers = marker_objects.map(m => {\n        return {\n          name: m.name,\n          id: m.id,\n          coord: m.coordinates.split(', ').map(c => parseFloat(c))\n        }\n      })\n      console.log(this.markers)\n    },\n    async openModal(id) {\n      const counter = useCounterStore()\n      counter.count = id\n      // console.log(counter.count)\n\n      const modal = await modalController\n        .create({\n          component: Modal,\n          initialBreakpoint: 0.5,\n          breakpoints: [0, 0.5, 1],\n          username: \"matt\"\n        })\n      return modal.present();\n    },  \n  }\n});\n</script>\n\n<style>\n</style>\n","import { watch, ref, provide, h, inject, onUnmounted, onBeforeUnmount, onMounted, nextTick, render as render$3, reactive, computed } from 'vue';\n\nconst debounce = (fn, time) => {\n  let timeout;\n\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\n\nconst capitalizeFirstLetter = (string) => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nconst propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal, oldVal) => {\n          methods[setMethodName](newVal, oldVal);\n        }\n      );\n    } else if (leafletElement[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal) => {\n          leafletElement[setMethodName](newVal);\n        }\n      );\n    }\n  }\n};\n\nconst remapEvents = (contextAttrs) => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (\n      attrName.startsWith(\"on\") &&\n      !attrName.startsWith(\"onUpdate\") &&\n      attrName !== \"onReady\"\n    ) {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\n\nconst resetWebpackIcon = async (Icon) => {\n  const modules = await Promise.all([\n    import('leaflet/dist/images/marker-icon-2x.png'),\n    import('leaflet/dist/images/marker-icon.png'),\n    import('leaflet/dist/images/marker-shadow.png'),\n  ]);\n\n  delete Icon.Default.prototype._getIconUrl;\n\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default,\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nconst provideLeafletWrapper = (methodName) => {\n  const wrapped = ref(() =>\n    console.warn(`Method ${methodName} has been invoked without being replaced`)\n  );\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nconst updateLeafletWrapper = (wrapper, leafletMethod) =>\n  (wrapper.wrapped.value = leafletMethod);\n\nconst WINDOW_OR_GLOBAL =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  undefined;\n\nconst GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\n\nconst props = {\n  options: {\n    type: Object,\n    default: () => ({}),\n  },\n};\n\nconst setup = (props) => {\n  return { options: props.options, methods: {} };\n};\n\nconst props$1 = {\n  ...props,\n  pane: {\n    type: String,\n    default: \"overlayPane\",\n  },\n  attribution: {\n    type: String,\n    default: null,\n  },\n  name: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  layerType: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  visible: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n};\n\nconst setup$1 = (props, leafletRef, context) => {\n  const addLayer = inject(\"addLayer\");\n  const removeLayer = inject(\"removeLayer\");\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setup(props);\n\n  const options = {\n    ...componentOptions,\n    attribution: props.attribution,\n    pane: props.pane,\n  };\n\n  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });\n  const removeThisLayer = () =>\n    removeLayer({ leafletObject: leafletRef.value });\n\n  const methods = {\n    ...componentMethods,\n    setAttribution(val, old) {\n      const attributionControl = this.$parent.leafletObject.attributionControl;\n      attributionControl.removeAttribution(old).addAttribution(val);\n    },\n    setName() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setLayerType() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setVisible(isVisible) {\n      if (leafletRef.value) {\n        if (isVisible) {\n          addThisLayer();\n        } else {\n          removeThisLayer();\n        }\n      }\n    },\n    bindPopup({ leafletObject }) {\n      leafletRef.value.bindPopup(leafletObject);\n    },\n    bindTooltip({ leafletObject }) {\n      leafletRef.value.bindTooltip(leafletObject);\n    },\n    unbindTooltip() {\n      const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;\n      if (tooltip) {\n        tooltip.unbindTooltip();\n      }\n    },\n    unbindPopup() {\n      const popup = leafletRef.value ? leafletRef.value.getPopup() : null;\n      if (popup) {\n        popup.unbindPopup();\n      }\n    },\n    updateVisibleProp(value) {\n      /**\n       * Triggers when the visible prop needs to be updated\n       * @type {boolean}\n       * @property {boolean} value - value of the visible property\n       */\n      context.emit(\"update:visible\", value);\n    },\n  };\n\n  provide(\"bindPopup\", methods.bindPopup);\n  provide(\"bindTooltip\", methods.bindTooltip);\n  provide(\"unbindTooltip\", methods.unbindTooltip);\n  provide(\"unbindPopup\", methods.unbindPopup);\n\n  onUnmounted(() => {\n    methods.unbindPopup();\n    methods.unbindTooltip();\n    removeThisLayer();\n  });\n\n  return { options, methods };\n};\n\nconst render = (ready, slots) => {\n  if (ready && slots.default) {\n    return h(\"div\", { style: { display: \"none\" } }, slots.default());\n  }\n};\n\nconst props$2 = {\n  ...props,\n  interactive: {\n    type: Boolean,\n    default: true,\n  },\n  bubblingMouseEvents: {\n    type: Boolean,\n    default: true,\n  },\n};\n\nconst setup$2 = (props) => {\n  const { options: componentOptions, methods } = setup(props);\n  const options = {\n    ...componentOptions,\n    interactive: props.interactive,\n    bubblingMouseEvents: props.bubblingMouseEvents,\n  };\n\n  return { options, methods };\n};\n\nconst props$3 = {\n  ...props$1,\n  ...props$2,\n  stroke: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  color: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  weight: {\n    type: Number,\n    custom: true,\n    default: 3,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  lineCap: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  lineJoin: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  dashArray: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  dashOffset: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  fill: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  fillColor: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  fillOpacity: {\n    type: Number,\n    custom: true,\n    default: 0.2,\n  },\n  fillRule: {\n    type: String,\n    custom: true,\n    default: \"evenodd\",\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n};\n\nconst setup$3 = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const {\n    options: interactiveLayerOptions,\n    methods: interactiveLayerMethods,\n  } = setup$2(props);\n\n  const removeLayer = inject(\"removeLayer\");\n\n  const options = {\n    ...layerOptions,\n    ...interactiveLayerOptions,\n    stroke: props.stroke,\n    color: props.color,\n    weight: props.weight,\n    opacity: props.opacity,\n    lineCap: props.lineCap,\n    lineJoin: props.lineJoin,\n    dashArray: props.dashArray,\n    dashOffset: props.dashOffset,\n    fill: props.fill,\n    fillColor: props.fillColor,\n    fillOpacity: props.fillOpacity,\n    fillRule: props.fillRule,\n    className: props.className,\n  };\n  const methods = {\n    ...layerMethods,\n    ...interactiveLayerMethods,\n    setStroke(stroke) {\n      leafletRef.value.setStyle({ stroke });\n    },\n    setColor(color) {\n      leafletRef.value.setStyle({ color });\n    },\n    setWeight(weight) {\n      leafletRef.value.setStyle({ weight });\n    },\n    setOpacity(opacity) {\n      leafletRef.value.setStyle({ opacity });\n    },\n    setLineCap(lineCap) {\n      leafletRef.value.setStyle({ lineCap });\n    },\n    setLineJoin(lineJoin) {\n      leafletRef.value.setStyle({ lineJoin });\n    },\n    setDashArray(dashArray) {\n      leafletRef.value.setStyle({ dashArray });\n    },\n    setDashOffset(dashOffset) {\n      leafletRef.value.setStyle({ dashOffset });\n    },\n    setFill(fill) {\n      leafletRef.value.setStyle({ fill });\n    },\n    setFillColor(fillColor) {\n      leafletRef.value.setStyle({ fillColor });\n    },\n    setFillOpacity(fillOpacity) {\n      leafletRef.value.setStyle({ fillOpacity });\n    },\n    setFillRule(fillRule) {\n      leafletRef.value.setStyle({ fillRule });\n    },\n    setClassName(className) {\n      leafletRef.value.setStyle({ className });\n    },\n  };\n\n  onBeforeUnmount(() => {\n    removeLayer({ leafletObject: leafletRef.value });\n  });\n\n  return { options, methods };\n};\n\nconst props$4 = {\n  ...props$3,\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  /**\n   * Radius of the marker in pixels.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nconst setup$4 = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setup$3(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n  const methods = {\n    ...pathMethods,\n    setRadius(radius) {\n      leafletRef.value.setRadius(radius);\n    },\n    setLatLng(latLng) {\n      leafletRef.value.setLatLng(latLng);\n    },\n  };\n\n  return { options, methods };\n};\n\nconst props$5 = {\n  ...props$4,\n  /**\n   * Radius of the circle in meters.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nconst setup$5 = (props, leafletRef, context) => {\n  const {\n    options: circleMarkerOptions,\n    methods: circleMarkerMethods,\n  } = setup$4(props, leafletRef, context);\n\n  const options = {\n    ...circleMarkerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...circleMarkerMethods,\n  };\n\n  return { options, methods };\n};\n\n/**\n * Circle component, lets you add and personalize circles on the map\n */\nvar script = {\n  name: \"LCircle\",\n  props: props$5,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$5(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circle, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = circle(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript.__file = \"src/components/LCircle.vue\";\n\n/**\n * Circle Marker component, lets you add and personalize circle markers on the map\n */\nvar script$1 = {\n  name: \"LCircleMarker\",\n  props: props$4,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$4(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circleMarker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = circleMarker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$1.__file = \"src/components/LCircleMarker.vue\";\n\nconst props$6 = {\n  ...props,\n  position: {\n    type: String,\n    default: \"topright\",\n  },\n};\n\nconst setup$6 = (props, leafletRef) => {\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setup(props);\n  const options = {\n    ...componentOptions,\n    position: props.position,\n  };\n\n  const methods = {\n    ...componentMethods,\n    setPosition(position) {\n      if (leafletRef.value) {\n        leafletRef.value.setPosition(position);\n      }\n    },\n  };\n\n  onUnmounted(() => {\n    if (leafletRef.value) {\n      leafletRef.value.remove();\n    }\n  });\n\n  return { options, methods };\n};\n\nconst render$1 = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n\nvar script$2 = {\n  name: \"LControl\",\n  props: {\n    ...props$6,\n    disableClickPropagation: {\n      type: Boolean,\n      custom: true,\n      default: true,\n    },\n    disableScrollPropagation: {\n      type: Boolean,\n      custom: true,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$6(props, leafletRef);\n\n    onMounted(async () => {\n      const { Control, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      const LControl = Control.extend({\n        onAdd() {\n          return root.value;\n        },\n      });\n\n      leafletRef.value = new LControl(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n\n      if (props.disableClickPropagation) {\n        DomEvent.disableClickPropagation(root.value);\n      }\n      if (props.disableScrollPropagation) {\n        DomEvent.disableScrollPropagation(root.value);\n      }\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$1(this.$slots);\n  },\n};\n\nscript$2.__file = \"src/components/LControl.vue\";\n\nconst props$7 = {\n  ...props$6,\n  prefix: {\n    type: String,\n    default: \"Vue-Leaflet\",\n    custom: true,\n  },\n};\n\nconst setup$7 = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    prefix: props.prefix,\n  };\n\n  const methods = {\n    ...controlMethods,\n    setPrefix(prefix) {\n      leafletRef.value.setPrefix(prefix);\n    },\n  };\n\n  return { options, methods };\n};\n\nvar script$3 = {\n  name: \"LControlAttribution\",\n  props: props$7,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$7(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.attribution(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$3.__file = \"src/components/LControlAttribution.vue\";\n\nconst props$8 = {\n  ...props$6,\n  collapsed: {\n    type: Boolean,\n    default: true,\n  },\n  autoZIndex: {\n    type: Boolean,\n    default: true,\n  },\n  hideSingleBase: {\n    type: Boolean,\n    default: false,\n  },\n  sortLayers: {\n    type: Boolean,\n    default: false,\n  },\n  sortFunction: {\n    type: Function,\n    default: undefined,\n  },\n};\n\nconst setup$8 = (props, leafletRef) => {\n  const { options: controlOptions } = setup$6(props, leafletRef);\n  const options = {\n    ...controlOptions,\n    collapsed: props.collapsed,\n    autoZIndex: props.autoZIndex,\n    hideSingleBase: props.hideSingleBase,\n    sortLayers: props.sortLayers,\n    sortFunction: props.sortFunction,\n  };\n\n  const methods = {\n    addLayer(layer) {\n      if (layer.layerType === \"base\") {\n        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);\n      } else if (layer.layerType === \"overlay\") {\n        leafletRef.value.addOverlay(layer.leafletObject, layer.name);\n      }\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n  return { options, methods };\n};\n\nvar script$4 = {\n  name: \"LControlLayers\",\n  props: props$8,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerLayerControl = inject(\"registerLayerControl\");\n\n    const { options, methods } = setup$8(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.layers(null, null, options);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      registerLayerControl({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$4.__file = \"src/components/LControlLayers.vue\";\n\nconst props$9 = {\n  ...props$6,\n  maxWidth: {\n    type: Number,\n    default: 100,\n  },\n  metric: {\n    type: Boolean,\n    default: true,\n  },\n  imperial: {\n    type: Boolean,\n    default: true,\n  },\n  updateWhenIdle: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nconst setup$9 = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    maxWidth: props.maxWidth,\n    metric: props.metric,\n    imperial: props.imperial,\n    updateWhenIdle: props.updateWhenIdle,\n  };\n\n  return { options, methods: controlMethods };\n};\n\nvar script$5 = {\n  name: \"LControlScale\",\n  props: props$9,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$9(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.scale(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$5.__file = \"src/components/LControlScale.vue\";\n\nconst props$a = {\n  ...props$6,\n  zoomInText: {\n    type: String,\n    default: \"+\",\n  },\n  zoomInTitle: {\n    type: String,\n    default: \"Zoom in\",\n  },\n  zoomOutText: {\n    type: String,\n    default: \"-\",\n  },\n  zoomOutTitle: {\n    type: String,\n    default: \"Zoom out\",\n  },\n};\n\nconst setup$a = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    zoomInText: props.zoomInText,\n    zoomInTitle: props.zoomInTitle,\n    zoomOutText: props.zoomOutText,\n    zoomOutTitle: props.zoomOutTitle,\n  };\n\n  return { options, methods: controlMethods };\n};\n\nvar script$6 = {\n  name: \"LControlZoom\",\n  props: props$a,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$a(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.zoom(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$6.__file = \"src/components/LControlZoom.vue\";\n\nconst props$b = {\n  ...props$1,\n};\n\nconst setup$b = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = {\n    ...layerOptions,\n  };\n\n  const methods = {\n    ...layerMethods,\n    addLayer(layer) {\n      leafletRef.value.addLayer(layer.leafletObject);\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n\n  provide(\"addLayer\", methods.addLayer);\n  provide(\"removeLayer\", methods.removeLayer);\n\n  return { options, methods };\n};\n\nconst props$c = {\n  ...props$b,\n};\n\nconst setup$c = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setup$b(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n  };\n\n  return { options, methods };\n};\n\nvar script$7 = {\n  props: props$c,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setup$c(props, leafletRef);\n\n    onMounted(async () => {\n      const { featureGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = featureGroup(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$7.__file = \"src/components/LFeatureGroup.vue\";\n\nconst props$d = {\n  ...props$b,\n  geojson: {\n    type: [Object, Array],\n    default: () => ({}),\n  },\n};\n\nconst setup$d = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setup$b(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n    setGeojson(newVal) {\n      leafletRef.value.clearLayers();\n      leafletRef.value.addData(newVal);\n    },\n    getGeoJSONData() {\n      return leafletRef.value.toGeoJSON();\n    },\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n  };\n\n  return { options, methods };\n};\n\nvar script$8 = {\n  props: props$d,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setup$d(props, leafletRef);\n\n    onMounted(async () => {\n      const { geoJSON, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = geoJSON(props.geojson, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$8.__file = \"src/components/LGeoJson.vue\";\n\nconst props$e = {\n  ...props$1,\n  pane: {\n    type: String,\n    default: \"tilePane\",\n  },\n  opacity: {\n    type: Number,\n    custom: false,\n    default: 1.0,\n  },\n  zIndex: {\n    type: Number,\n    default: 1,\n  },\n  tileSize: {\n    type: Number,\n    default: 256,\n  },\n  noWrap: {\n    type: Boolean,\n    default: false,\n  },\n  minZoom: {\n    type: Number,\n    default: 0,\n  },\n  maxZoom: {\n    type: Number,\n    default: undefined,\n  },\n};\n\nconst setup$e = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    pane: props.pane,\n    opacity: props.opacity,\n    zIndex: props.zIndex,\n    tileSize: props.tileSize,\n    noWrap: props.noWrap,\n    minZoom: props.minZoom,\n    maxZoom: props.maxZoom,\n  };\n  return { options, methods: { ...layerMethods } };\n};\n\nvar script$9 = {\n  props: {\n    ...props$e,\n    childRender: {\n      type: Function,\n      required: true,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const tileComponents = ref({});\n    const root = ref(null);\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$e(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      methods.onUnload = (e) => {\n        const key = leafletRef.value._tileCoordsToKey(e.coords);\n        if (tileComponents[key]) {\n          tileComponents[key].innerHTML = \"\";\n          tileComponents[key] = undefined;\n        }\n      };\n\n      methods.setTileComponent = () => {\n        leafletRef.value.redraw();\n      };\n\n      const GLayer = GridLayer.extend({\n        createTile(coords) {\n          const key = leafletRef.value._tileCoordsToKey(coords);\n          tileComponents[key] = DomUtil.create(\"div\");\n\n          let vNode = h(\n            { setup: props.childRender, props: [\"coords\"] },\n            { coords }\n          );\n          render$3(vNode, tileComponents[key]);\n\n          return tileComponents[key];\n        },\n      });\n\n      leafletRef.value = new GLayer(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"tileunload\", methods.onUnload);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    onUnmounted(() => {\n      leafletRef.value.off(\"tileunload\", methods.unLoad);\n    });\n\n    return { root, ready, leafletObject: leafletRef };\n  },\n  render() {\n    if (this.ready) {\n      return h(\"div\", { style: { display: \"none\" }, ref: \"root\" });\n    }\n    return null;\n  },\n};\n\nscript$9.__file = \"src/components/LGridLayer.vue\";\n\nconst props$f = {\n  iconUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  iconAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  popupAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  tooltipAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  shadowUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  shadowAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  bgPos: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  options: {\n    type: Object,\n    custom: true,\n    default: () => ({}),\n  },\n};\n\n/**\n * Icon component, lets you add and custom icons to the map\n */\nvar script$a = {\n  name: \"LIcon\",\n  props: {\n    ...props$f,\n    ...props,\n  },\n  setup(props, context) {\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const canSetParentHtml = inject(\"canSetParentHtml\");\n    const setParentHtml = inject(\"setParentHtml\");\n    const setIcon = inject(\"setIcon\");\n\n    let onDomEvent;\n    let offDomEvent;\n    let divIcon;\n    let icon;\n    let iconObject = undefined;\n\n    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {\n      const elHtml = el && el.innerHTML;\n      if (!recreationNeeded) {\n        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {\n          setParentHtml(elHtml);\n        }\n        return;\n      }\n\n      const listeners = remapEvents(context.attrs);\n      if (iconObject) {\n        offDomEvent(iconObject, listeners);\n      }\n\n      const { options: componentOptions } = setup(props);\n      const options = {\n        ...componentOptions,\n        iconUrl: props.iconUrl,\n        iconRetinaUrl: props.iconRetinaUrl,\n        iconSize: props.iconSize,\n        iconAnchor: props.iconAnchor,\n        popupAnchor: props.popupAnchor,\n        tooltipAnchor: props.tooltipAnchor,\n        shadowUrl: props.shadowUrl,\n        shadowRetinaUrl: props.shadowRetinaUrl,\n        shadowSize: props.shadowSize,\n        shadowAnchor: props.shadowAnchor,\n        bgPos: props.bgPos,\n        className: props.className,\n        html: elHtml || props.html,\n      };\n\n      iconObject = options.html ? divIcon(options) : icon(options);\n      onDomEvent(iconObject, listeners);\n      setIcon(iconObject);\n    };\n\n    const scheduleCreateIcon = () => {\n      nextTick(() => createIcon(root.value, true, false));\n    };\n\n    const scheduleHtmlSwap = () => {\n      nextTick(() => createIcon(root.value, false, true));\n    };\n\n    const methods = {\n      setIconUrl: scheduleCreateIcon,\n      setIconRetinaUrl: scheduleCreateIcon,\n      setIconSize: scheduleCreateIcon,\n      setIconAnchor: scheduleCreateIcon,\n      setPopupAnchor: scheduleCreateIcon,\n      setTooltipAnchor: scheduleCreateIcon,\n      setShadowUrl: scheduleCreateIcon,\n      setShadowRetinaUrl: scheduleCreateIcon,\n      setShadowAnchor: scheduleCreateIcon,\n      setBgPos: scheduleCreateIcon,\n      setClassName: scheduleCreateIcon,\n      setHtml: scheduleCreateIcon,\n    };\n\n    onMounted(async () => {\n      const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      onDomEvent = DomEvent.on;\n      offDomEvent = DomEvent.off;\n      divIcon = lDivIcon;\n      icon = lIcon;\n\n      propsBinder(methods, {}, props);\n\n      const observer = new MutationObserver(scheduleHtmlSwap);\n      observer.observe(root.value, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true,\n      });\n      scheduleCreateIcon();\n    });\n\n    return { root };\n  },\n  render() {\n    const content = this.$slots.default ? this.$slots.default() : undefined;\n    return h(\"div\", { ref: \"root\" }, content);\n  },\n};\n\nscript$a.__file = \"src/components/LIcon.vue\";\n\n/**\n * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds\n */\n\nconst props$g = {\n  ...props$1,\n  url: {\n    type: String,\n    required: true,\n  },\n  bounds: {\n    type: [Array, Object],\n    required: true,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  alt: {\n    type: String,\n    default: \"\",\n  },\n  interactive: {\n    type: Boolean,\n    default: false,\n  },\n  crossOrigin: {\n    type: Boolean,\n    default: false,\n  },\n  errorOverlayUrl: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  zIndex: {\n    type: Number,\n    custom: true,\n    default: 1,\n  },\n  className: {\n    type: String,\n    default: \"\",\n  },\n};\n\nconst setup$f = (setupProps, LeafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    setupProps,\n    LeafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...setupProps,\n  };\n\n  const methods = {\n    ...layerMethods,\n    /**\n     * Sets the opacity of the overlay.\n     * @param {number} opacity\n     */\n    setOpacity(opacity) {\n      return LeafletRef.value.setOpacity(opacity);\n    },\n    /**\n     * Changes the URL of the image.\n     * @param {string} url\n     */\n    setUrl(url) {\n      return LeafletRef.value.setUrl(url);\n    },\n    /**\n     * Update the bounds that this ImageOverlay covers\n     * @param {LatLngBounds | Array<Array<number>>} bounds\n     */\n    setBounds(bounds) {\n      return LeafletRef.value.setBounds(bounds);\n    },\n    /**\n     * Get the bounds that this ImageOverlay covers\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n      return LeafletRef.value.getBounds();\n    },\n    /**\n     * Returns the instance of HTMLImageElement used by this overlay.\n     * @returns {HTMLElement}\n     */\n    getElement() {\n      return LeafletRef.value.getElement();\n    },\n    /**\n     * Brings the layer to the top of all overlays.\n     */\n    bringToFront() {\n      return LeafletRef.value.bringToFront();\n    },\n    /**\n     * Brings the layer to the bottom of all overlays.\n     */\n    bringToBack() {\n      return LeafletRef.value.bringToBack();\n    },\n    /**\n     * Changes the zIndex of the image overlay.\n     * @param {number} zIndex\n     */\n    setZIndex(zIndex) {\n      return LeafletRef.value.setZIndex(zIndex);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * ImageOverlay component, render a plain image instead of a geospatial map.\n */\nvar script$b = {\n  name: \"LImageOverlay\",\n  props: props$g,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$f(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { imageOverlay, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = imageOverlay(props.url, props.bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$b.__file = \"src/components/LImageOverlay.vue\";\n\nvar script$c = {\n  props: props$b,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods } = setup$b(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { layerGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = layerGroup(props.options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$c.__file = \"src/components/LLayerGroup.vue\";\n\nvar script$d = {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: {\n    ...props,\n    /**\n     * The center of the map, supports .sync modifier\n     */\n    center: {\n      type: [Object, Array],\n      default: () => [0, 0],\n    },\n    /**\n     * The bounds of the map, supports .sync modifier\n     */\n    bounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The max bounds of the map\n     */\n    maxBounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The zoom of the map, supports .sync modifier\n     */\n    zoom: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * The minZoom of the map\n     */\n    minZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The maxZoom of the map\n     */\n    maxZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The paddingBottomRight of the map\n     */\n    paddingBottomRight: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The paddingTopLeft of the map\n     */\n    paddingTopLeft: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The padding of the map\n     */\n    padding: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The worldCopyJump option for the map\n     */\n    worldCopyJump: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The CRS to use for the map. Can be an object that defines a coordinate reference\n     * system for projecting geographical points into screen coordinates and back\n     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n     * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n     */\n    crs: {\n      type: [String, Object],\n      default: \"EPSG3857\",\n    },\n    maxBoundsViscosity: {\n      type: Number,\n      default: undefined,\n    },\n    inertia: {\n      type: Boolean,\n      default: undefined,\n    },\n    inertiaDeceleration: {\n      type: Number,\n      default: undefined,\n    },\n    inertiaMaxSpeed: {\n      type: Number,\n      default: undefined,\n    },\n    easeLinearity: {\n      type: Number,\n      default: undefined,\n    },\n    zoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    zoomAnimationThreshold: {\n      type: Number,\n      default: undefined,\n    },\n    fadeAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    markerZoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    noBlockingAnimations: {\n      type: Boolean,\n      default: false,\n    },\n    useGlobalLeaflet: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: [],\n    });\n    const { options: componentOptions } = setup(props);\n    const options = {\n      ...componentOptions,\n      minZoom: props.minZoom,\n      maxZoom: props.maxZoom,\n      maxBounds: props.maxBounds,\n      maxBoundsViscosity: props.maxBoundsViscosity,\n      worldCopyJump: props.worldCopyJump,\n      crs: props.crs,\n      center: props.center,\n      zoom: props.zoom,\n      inertia: props.inertia,\n      inertiaDeceleration: props.inertiaDeceleration,\n      inertiaMaxSpeed: props.inertiaMaxSpeed,\n      easeLinearity: props.easeLinearity,\n      zoomAnimation: props.zoomAnimation,\n      zoomAnimationThreshold: props.zoomAnimationThreshold,\n      fadeAnimation: props.fadeAnimation,\n      markerZoomAnimation: props.markerZoomAnimation,\n    };\n\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      },\n    };\n\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import('leaflet'));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent,\n      } = props.useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(\n          `The following error occurred running the provided beforeMapMount hook ${error.message}`\n        );\n      }\n\n      await resetWebpackIcon(Icon);\n\n      const optionsCrs =\n        typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(\n                (l) =>\n                  l.leafletObject._leaflet_id ===\n                  layer.leafletObject._leaflet_id\n              );\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(\n                (l) => l.name !== layer.name\n              );\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(\n                (l) =>\n                  l.leafletObject._leaflet_id !==\n                  layer.leafletObject._leaflet_id\n              );\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach((layer) => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n\n          registerControl(lControlLayer);\n        },\n\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0],\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null,\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds =\n            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter =\n            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (\n            oldCenter.lat !== newCenter.lat ||\n            oldCenter.lng !== newCenter.lng\n          ) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n      };\n\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n\n      blueprint.leafletRef = map(root.value, options);\n\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n\n      blueprint.leafletRef.on(\n        \"moveend\",\n        debounce(eventHandlers.moveEndHandler, 100)\n      );\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\n        \"overlayremove\",\n        eventHandlers.overlayRemoveHandler\n      );\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.remove();\n      }\n    });\n\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return { root, ready, leafletObject };\n  },\n  render() {\n    return h(\n      \"div\",\n      { style: { width: \"100%\", height: \"100%\" }, ref: \"root\" },\n      this.ready ? this.$slots.default() : {}\n    );\n  },\n};\n\nscript$d.__file = \"src/components/LMap.vue\";\n\nconst props$h = {\n  ...props$1,\n  pane: {\n    type: String,\n    default: \"markerPane\",\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  icon: {\n    type: [Object],\n    default: () => undefined,\n    custom: false,\n  },\n  zIndexOffset: {\n    type: Number,\n    custom: false,\n    default: null,\n  },\n};\n\nconst setup$g = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerMethods,\n    setDraggable(value) {\n      if (leafletRef.value.dragging) {\n        value\n          ? leafletRef.value.dragging.enable()\n          : leafletRef.value.dragging.disable();\n      }\n    },\n    latLngSync(event) {\n      context.emit(\"update:latLng\", event.latlng);\n      context.emit(\"update:lat-lng\", event.latlng);\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n\n      if (leafletRef.value) {\n        const oldLatLng = leafletRef.value.getLatLng();\n        if (!oldLatLng || !oldLatLng.equals(newVal)) {\n          leafletRef.value.setLatLng(newVal);\n        }\n      }\n    },\n  };\n  return { options, methods };\n};\n\n/**\n * Marker component, lets you add and personalize markers on the map\n */\nvar script$e = {\n  name: \"LMarker\",\n  props: props$h,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    provide(\"canSetParentHtml\", () => !!leafletRef.value.getElement());\n    provide(\n      \"setParentHtml\",\n      (html) => (leafletRef.value.getElement().innerHTML = html)\n    );\n    provide(\n      \"setIcon\",\n      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)\n    );\n    const { options, methods } = setup$g(props, leafletRef, context);\n    if (options.icon === undefined) {\n      // If the options objection has a property named 'icon', then Leaflet will overwrite\n      // the default icon with it for the marker, _even if it is undefined_.\n      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130\n      delete options.icon;\n    }\n\n    onMounted(async () => {\n      const { marker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = marker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"move\", debounce(methods.latLngSync, 100));\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$e.__file = \"src/components/LMarker.vue\";\n\nconst props$i = {\n  ...props$3,\n  latLngs: {\n    type: Array,\n    default: () => [],\n  },\n  smoothFactor: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  noClip: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n};\n\nconst setup$h = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setup$3(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...pathMethods,\n    setSmoothFactor(smoothFactor) {\n      leafletRef.value.setStyle({ smoothFactor });\n    },\n    setNoClip(noClip) {\n      leafletRef.value.setStyle({ noClip });\n    },\n    addLatLng(latLng) {\n      leafletRef.value.addLatLng(latLng);\n    },\n  };\n  return { options, methods };\n};\n\nconst props$j = {\n  ...props$i,\n};\n\nconst setup$i = (props, leafletRef, context) => {\n  const { options: polylineOptions, methods: polylineMethods } = setup$h(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polylineOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polylineMethods,\n    toGeoJSON(precision) {\n      return leafletRef.value.toGeoJSON(precision);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * Polygon component, lets you add and customize polygon regions on the map\n */\nvar script$f = {\n  name: \"LPolygon\",\n  props: props$j,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$i(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polygon, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = polygon(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$f.__file = \"src/components/LPolygon.vue\";\n\n/**\n * Polyline component, lets you add and personalize polylines on the map\n */\nvar script$g = {\n  name: \"LPolyline\",\n  props: props$i,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$h(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polyline, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = polyline(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$g.__file = \"src/components/LPolyline.vue\";\n\nconst props$k = {\n  ...props,\n  content: {\n    type: String,\n    default: null,\n  },\n};\n\nconst setup$j = (props, leafletRef) => {\n  const { options, methods: componentMethods } = setup(props);\n  const methods = {\n    ...componentMethods,\n    setContent(newVal) {\n      if (leafletRef.value && newVal !== null && newVal !== undefined) {\n        leafletRef.value.setContent(newVal);\n      }\n    },\n  };\n  return { options, methods };\n};\n\nconst render$2 = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n\nconst props$l = {\n  ...props$k,\n  latLng: {\n    type: [Object, Array],\n    default: () => [],\n  },\n};\n\nconst setup$k = (props, leafletRef) => {\n  const { options, methods } = setup$j(props, leafletRef);\n  const unbindPopup = inject(\"unbindPopup\");\n\n  onBeforeUnmount(() => {\n    unbindPopup();\n  });\n\n  return { options, methods };\n};\n\n/**\n * Display a popup on the map\n */\nvar script$h = {\n  name: \"LPopup\",\n  props: props$l,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindPopup = inject(\"bindPopup\");\n\n    const { options, methods } = setup$k(props, leafletRef);\n\n    onMounted(async () => {\n      const { popup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = popup(options);\n\n      if (props.latLng !== undefined) {\n        leafletRef.value.setLatLng(props.latLng);\n      }\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindPopup({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$2(this.$slots);\n  },\n};\n\nscript$h.__file = \"src/components/LPopup.vue\";\n\nconst props$m = {\n  ...props$j,\n  bounds: {\n    type: Array,\n    default: undefined,\n  },\n};\n\nconst setup$l = (props, leafletRef, context) => {\n  const { options: polygonOptions, methods: polygonMethods } = setup$i(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polygonOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polygonMethods,\n    setBounds(latLngBounds) {\n      leafletRef.value.setBounds(latLngBounds);\n    },\n    setLatLngs(latLngs) {\n      // Calling setLatLngs on a Leaflet rectangle will convert it\n      // to a polygon. So instead, we call setBounds here to ensure\n      // that the rectangle remains a rectangle, defined by the\n      // bounds of the points in the latLngs array.\n      leafletRef.value.setBounds(latLngs);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * Rectangle component, lets you add and customize rectangular regions on the map\n */\nvar script$i = {\n  name: \"LRectangle\",\n  props: props$m,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$l(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      const bounds =\n        props.bounds && props.bounds.length\n          ? latLngBounds(props.bounds)\n          : latLngBounds(props.latLngs);\n      leafletRef.value = rectangle(bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$i.__file = \"src/components/LRectangle.vue\";\n\nconst props$n = {\n  ...props$e,\n  tms: {\n    type: Boolean,\n    default: false,\n  },\n  subdomains: {\n    type: String,\n    default: \"abc\",\n  },\n  detectRetina: {\n    type: Boolean,\n    default: false,\n  },\n  url: {\n    type: String,\n    default: null,\n  },\n};\n\nconst setup$m = (props, leafletRef) => {\n  const {\n    options: gridLayerOptions,\n    methods: gridLayerMethods,\n  } = setup$e(props, leafletRef);\n  const options = {\n    ...gridLayerOptions,\n    tms: props.tms,\n    subdomains: props.subdomains,\n    detectRetina: props.detectRetina,\n  };\n  return {\n    options,\n    methods: {\n      ...gridLayerMethods,\n    },\n  };\n};\n\nvar script$j = {\n  props: props$n,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$m(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = tileLayer(props.url, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { leafletObject: leafletRef };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$j.__file = \"src/components/LTileLayer.vue\";\n\nconst props$o = {\n  ...props$k,\n};\n\nconst setup$n = (props, leafletRef) => {\n  const { options, methods } = setup$j(props, leafletRef);\n  const unbindTooltip = inject(\"unbindTooltip\");\n\n  onBeforeUnmount(() => {\n    unbindTooltip();\n  });\n\n  return { options, methods };\n};\n\n/**\n * Display a tooltip on the map\n */\nvar script$k = {\n  name: \"LTooltip\",\n  props: props$o,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindTooltip = inject(\"bindTooltip\");\n\n    const { options, methods } = setup$n(props, leafletRef);\n\n    onMounted(async () => {\n      const { tooltip, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = tooltip(options);\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindTooltip({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$2(this.$slots);\n  },\n};\n\nscript$k.__file = \"src/components/LTooltip.vue\";\n\nconst props$p = {\n  ...props$n,\n  baseUrl: {\n    type: String,\n    default: null,\n    required: true,\n  },\n  layers: {\n    type: String,\n    default: \"\",\n  },\n  styles: {\n    type: String,\n    default: \"\",\n  },\n  format: {\n    type: String,\n    default: \"image/jpeg\",\n  },\n  transparent: {\n    type: Boolean,\n    custom: false,\n  },\n  version: {\n    type: String,\n    default: \"1.1.1\",\n  },\n  crs: {\n    default: null,\n  },\n  upperCase: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nconst setup$o = (props, leafletRef) => {\n  const {\n    options: tileLayerOptions,\n    methods: tileLayerMethods,\n  } = setup$m(props, leafletRef);\n  const options = {\n    ...tileLayerOptions,\n    layers: props.layers,\n    styles: props.styles,\n    format: props.format,\n    transparent: props.transparent,\n    version: props.version,\n    crs: props.crs,\n    upperCase: props.upperCase,\n  };\n  return {\n    options,\n    methods: {\n      ...tileLayerMethods,\n    },\n  };\n};\n\nvar script$l = {\n  props: props$p,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$o(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = tileLayer.wms(props.baseUrl, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$l.__file = \"src/components/LWmsTileLayer.vue\";\n\nexport { script as LCircle, script$1 as LCircleMarker, script$2 as LControl, script$3 as LControlAttribution, script$4 as LControlLayers, script$5 as LControlScale, script$6 as LControlZoom, script$7 as LFeatureGroup, script$8 as LGeoJson, script$9 as LGridLayer, script$a as LIcon, script$b as LImageOverlay, script$c as LLayerGroup, script$d as LMap, script$e as LMarker, script$f as LPolygon, script$g as LPolyline, script$h as LPopup, script$i as LRectangle, script$j as LTileLayer, script$k as LTooltip, script$l as LWmsTileLayer };\n//# sourceMappingURL=vue-leaflet.esm.js.map\n","<template>\n    <!-- Sheet Modal -->\n        <ion-content>\n            <ion-card \n                class=\"card\" \n                v-for=\"item in spot\" \n                :key=\"item.name\">\n                <ion-card-header>\n                    <ion-grid>\n                        <ion-row>\n                        <ion-col>\n                            <ion-card-title class=\"title\">\n                            {{ item.name }}\n                            </ion-card-title>\n                        </ion-col>\n                        <ion-col class=\"time_chip\">\n                            <ion-chip>\n                                <ion-icon \n                                    :icon=\"time\" \n                                    color=\"dark\">\n                                </ion-icon>\n                                <ion-label>\n                                    Ab {{ item.time }} Uhr\n                                </ion-label>\n                            </ion-chip>\n                        </ion-col>\n                        </ion-row>\n                    </ion-grid>\n                </ion-card-header>\n                <ion-card-content>\n                    <ion-grid>\n                        <ion-row>\n                            <ion-col>\n                                <p>\n                                    {{ item.description }}\n                                </p>\n                            </ion-col>\n                        </ion-row>\n                        <ion-row>\n                            <ion-col>\n                                <div\n                                    v-if=\"item.status == '1'\">\n                                    <ion-button \n                                        class=\"button\"\n                                        expand=\"block\" \n                                        color=\"danger\"\n                                        @click=\"presentActionSheet\">\n                                        Heute noch nicht besucht\n                                    </ion-button>\n                                </div>\n                                <div\n                                    v-if=\"item.status == '2'\">\n                                  <ion-button \n                                      class=\"button\"\n                                      expand=\"block\" \n                                      color=\"success\"\n                                      @click=\"presentActionSheet\"\n                                      >\n                                      Für heute schon alles gerettet\n                                  </ion-button>\n                                    <div>\n                                    </div>\n                                </div>\n                                <div\n                                    v-if=\"item.status == '3'\">\n                                  <ion-button \n                                      class=\"button\"\n                                      expand=\"block\" \n                                      color=\"warning\"\n                                      @click=\"presentActionSheet\"\n                                      >\n                                      Hier gibts noch was\n                                  </ion-button>\n                                    \n                                </div>\n                                <!-- //// -->\n                            </ion-col>\n                        </ion-row>\n                    </ion-grid>\n                </ion-card-content>\n            </ion-card>\n        </ion-content>\n</template>\n\n<script>\nimport { defineComponent } from 'vue';\nimport { useCounterStore } from '@/stores/counter'\nimport { supabase } from \"@/supabase\"\nimport { time } from 'ionicons/icons';\nimport { IonContent, \n    IonCard, \n    IonCardContent, \n    IonCardHeader, \n    IonCardTitle, \n    IonButton, \n    actionSheetController,\n    IonIcon,\n    IonLabel,\n    IonChip,\n    IonCol, \n    IonGrid, \n    IonRow } from '@ionic/vue';\n\nexport default defineComponent({\n  name: 'Tab2Page',\n  components: {\n    IonContent,\n    IonCard, \n    IonCardContent, \n    IonCardHeader, \n    IonCardTitle,\n    IonButton,\n    IonIcon,\n    IonLabel,\n    IonChip,\n    IonCol, \n    IonGrid, \n    IonRow\n    },\n  data: () => ({\n    spot: [],\n    time_since_close_value: '',\n    time_since_change_value_millisec: '',\n    time_since_change_value_minutes: '',\n    jetzt_total_minutes: '',\n    last_status_change: '',\n    heute: '',\n    last_status_change_month: '',\n  }),\n  setup() {\n    return { time }\n  },\n  async created() {\n    const counter = useCounterStore()\n    console.log(counter.count)\n    const {data: events} = await supabase\n      .from('events')\n      .select('description,name,status,time,last_status_change')\n      .eq('id', counter.count)\n    console.log(events)\n    this.spot = events\n    this.pre_reset()\n  },\n  methods: {\n    async presentActionSheet() {\n      const actionSheet = await actionSheetController\n        .create({\n          header: 'Status',\n          cssClass: 'my-custom-class',\n          buttons: [\n            {\n              text: 'Heute noch nicht besucht',\n              data: 10,  \n              handler: () => {\n                console.log('Share clicked')\n                this.changeStatus(1)\n              },\n            },\n            {\n              text: 'Für heute schon alles gerettet',\n              data: 'Data value',\n              handler: () => {\n                console.log('Play clicked')\n                this.changeStatus(2)\n              },\n            },\n            {\n              text: 'Hier gibts noch was',\n              handler: () => {\n                console.log('Favorite clicked')\n                this.changeStatus(3)\n              },\n            },\n            {\n              text: 'Abbrechen',\n              role: 'cancel',\n              handler: () => {\n                console.log('Abbrechen clicked')\n              },\n            },\n          ],\n        });\n      await actionSheet.present();\n\n      const { role, data } = await actionSheet.onDidDismiss();\n      console.log('onDidDismiss resolved with role and data', role, data);\n    },\n    async changeStatus(future_status) {\n        console.log(future_status)\n        const counter = useCounterStore()\n        const { data: error } = await supabase\n            .from('events')\n            .update({ status: future_status, last_status_change: new Date() })\n            .eq('id', counter.count )\n        console.log(error)\n        const {data: events} = await supabase\n            .from('events')\n            .select('description,name,status,last_status_change')\n            .eq('id', counter.count)\n        console.log(events)\n        this.spot = events\n    },\n    pre_reset() {\n      this.spot.forEach(element => {\n        this.reset(element.status, element.last_status_change, element.time)\n      });\n    },\n    reset(old_status, last_status_change, time) {\n        this.last_status_change = last_status_change\n        // const change_required = 0\n        if (old_status == 1) {\n          console.log('heute noch nicht besucht');\n        } else if (old_status == 2) {\n            this.time_since_close(time)\n        } else if (old_status == 3) {\n            this.time_since_close(time)\n        } else {\n            console.log('fehler. Der Wert ist nicht 1,2 oder 3');\n        }\n    },\n    time_since_close(time) {\n      console.log('time since close:')\n      // aktuelle Zeit:\n      this.heute = new Date();\n      const jetzt_hours = this.heute.getHours();\n      const jetzt_minutes = this.heute.getMinutes();\n      // Ladenschluss Zeit aufsplitten:\n      const time_split = time.split(':');\n      const time_hours = parseInt(time_split[0]);\n      const time_minutes = parseInt(time_split[1]);\n      // zeit in minuten\n      const time_total_minutes = (time_hours * 60) + time_minutes;\n      this.jetzt_total_minutes =(jetzt_hours * 60) + jetzt_minutes;\n      if (time_total_minutes > this.jetzt_total_minutes) {\n        this.time_since_close_value = 1440 - (time_total_minutes - this.jetzt_total_minutes)\n        console.log(this.time_since_close_value)\n        this.time_since_change()\n      }\n      else if (this.jetzt_total_minutes > time_total_minutes) {\n        this.time_since_close_value = this.jetzt_total_minutes - time_total_minutes\n        console.log(this.time_since_close_value)\n        this.time_since_change()\n      }\n      else if (time_total_minutes == this.jetzt_total_minutes) {\n        this.time_since_close_value = 0\n        console.log(this.time_since_close_value)\n        this.time_since_change()\n      }\n      else {\n        console.log('fehler')\n      }\n    },\n    time_since_change() {\n      console.log('time since change:')\n      const last_status_change_local = new Date(Date.parse(this.last_status_change) + (120 * 60000))\n      this.time_since_change_value_millisec = Date.parse(this.heute) - Date.parse(last_status_change_local)\n      this.time_since_change_value_minutes = this.time_since_change_value_millisec / 60000\n      console.log(this.time_since_change_value_minutes)\n      this.time_since_change_vs_time_since_close()\n    },\n    time_since_change_vs_time_since_close() {\n      if (this.time_since_change_value_minutes < this.time_since_close_value) {\n        console.log('Letzte Statusänderung war nach dem letzten Ladenschluss. Wird ausgegeben wie in db')\n      } else if (this.time_since_close_value < this.time_since_change_value_minutes) {\n        console.log('Letzter Ladenschluss war nach der letzten Statusänderung Status wird geändert')\n        // ToDo\n        this.changeStatus(1)\n        console.log('Status wurde geändert')\n\n      } else {\n        console.log('Fehler')\n      }\n    },\n  }\n})\n</script>\n\n<style scoped>\n.card {\n    margin-top: 15px;\n}\n.time_chip {\n    /* position: relative; */\n    text-align: right;\n}\n.title {\n    margin-top: 10px;\n}\n.button {\n    margin-top: 20px;\n}\n</style>\n","// stores/counter.js\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => {\n    return { count: 0 }\n  },\n  // could also be defined as\n  // state: () => ({ count: 0 })\n  actions: {\n    // increment() {\n    //   this.count++\n    //   console.log(this.count)\n    // },\n  },\n})\n\n","import { render } from \"./SpotModal.vue?vue&type=template&id=9c6aeab4&scoped=true\"\nimport script from \"./SpotModal.vue?vue&type=script&lang=js\"\nexport * from \"./SpotModal.vue?vue&type=script&lang=js\"\n\nimport \"./SpotModal.vue?vue&type=style&index=0&id=9c6aeab4&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/pumuckl/Dokumente/code/ionic/dumpster-diving-ionic/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-9c6aeab4\"]])\n\nexport default __exports__","import { render } from \"./Tab2Page.vue?vue&type=template&id=99831dda\"\nimport script from \"./Tab2Page.vue?vue&type=script&lang=js\"\nexport * from \"./Tab2Page.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/home/pumuckl/Dokumente/code/ionic/dumpster-diving-ionic/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["_createBlock","_component_ion_page","_createVNode","_component_ion_header","_component_ion_content","fullscreen","collapse","_component_ion_toolbar","_component_ion_title","size","_component_l_map","zoom","center","options","zoomControl","_component_l_tile_layer","style","url","_createElementBlock","_Fragment","_renderList","_ctx","marker","index","_component_l_marker","onClick","id","key","ref","coord","debounce","fn","time","timeout","args","context","this","clearTimeout","setTimeout","apply","capitalizeFirstLetter","string","charAt","toUpperCase","slice","propsBinder","methods","leafletElement","props","setMethodName","newVal","oldVal","remapEvents","contextAttrs","result","attrName","startsWith","eventName","toLocaleLowerCase","resetWebpackIcon","async","Icon","modules","Promise","all","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","default","iconUrl","shadowUrl","provideLeafletWrapper","methodName","wrapped","console","warn","wrapper","value","updateLeafletWrapper","leafletMethod","WINDOW_OR_GLOBAL","self","g","global","undefined","GLOBAL_LEAFLET_OPT","type","Object","setup","props$1","pane","String","attribution","name","custom","layerType","visible","Boolean","setup$1","leafletRef","addLayer","removeLayer","componentOptions","componentMethods","addThisLayer","leafletObject","removeThisLayer","setAttribution","val","old","attributionControl","$parent","removeAttribution","addAttribution","setName","setLayerType","setVisible","isVisible","bindPopup","bindTooltip","unbindTooltip","tooltip","getTooltip","unbindPopup","popup","getPopup","updateVisibleProp","emit","ready","slots","h","display","props$2","interactive","bubblingMouseEvents","props$3","stroke","color","weight","Number","opacity","lineCap","lineJoin","dashArray","dashOffset","fill","fillColor","fillOpacity","fillRule","className","props$4","latLng","Array","radius","props$6","position","setup$6","setPosition","remove","render$1","props$b","props$e","zIndex","tileSize","noWrap","minZoom","maxZoom","setup$e","layerOptions","layerMethods","props$f","iconSize","iconAnchor","popupAnchor","tooltipAnchor","shadowRetinaUrl","shadowSize","shadowAnchor","bgPos","script$d","emits","bounds","maxBounds","paddingBottomRight","paddingTopLeft","padding","worldCopyJump","crs","maxBoundsViscosity","inertia","inertiaDeceleration","inertiaMaxSpeed","easeLinearity","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","noBlockingAnimations","useGlobalLeaflet","root","blueprint","layersToAdd","layersInControl","registerControl","registerLayerControl","eventHandlers","moveEndHandler","getZoom","getCenter","getBounds","overlayAddHandler","e","layer","find","l","overlayRemoveHandler","L","map","CRS","latLngBounds","DomEvent","beforeMapMount","error","message","optionsCrs","EPSG3857","layerControl","push","exist","_leaflet_id","filter","lControlLayer","forEach","lControl","addControl","setZoom","animate","setPaddingBottomRight","setPaddingTopLeft","setPadding","setCrs","prevBounds","fitBounds","setBounds","newBounds","isValid","oldBounds","lastSetBounds","boundsChanged","equals","fitBoundsOptions","setCenter","newCenter","oldCenter","lastSetCenter","lat","lng","panTo","listeners","attrs","on","render","width","height","$slots","props$h","draggable","icon","zIndexOffset","setup$g","setDraggable","dragging","enable","disable","latLngSync","event","latlng","setLatLng","oldLatLng","getLatLng","script$e","getElement","html","innerHTML","newIcon","setIcon","props$i","latLngs","smoothFactor","noClip","props$j","props$k","content","props$n","tms","subdomains","detectRetina","setup$m","gridLayerOptions","gridLayerMethods","script$j","tileLayer","_createElementVNode","item","_component_ion_card","class","_component_ion_card_header","_component_ion_grid","_component_ion_row","_component_ion_col","_component_ion_card_title","_component_ion_chip","_component_ion_icon","_component_ion_label","_toDisplayString","_component_ion_card_content","description","status","_hoisted_1","_component_ion_button","expand","_hoisted_3","_hoisted_5","_hoisted_6","useCounterStore","defineStore","state","count","actions","defineComponent","components","IonContent","IonCard","IonCardContent","IonCardHeader","IonCardTitle","IonButton","IonIcon","IonLabel","IonChip","IonCol","IonGrid","IonRow","data","spot","time_since_close_value","time_since_change_value_millisec","time_since_change_value_minutes","jetzt_total_minutes","last_status_change","heute","last_status_change_month","counter","log","events","supabase","select","eq","pre_reset","actionSheet","actionSheetController","header","cssClass","buttons","text","handler","changeStatus","role","present","onDidDismiss","future_status","update","Date","element","reset","old_status","time_since_close","jetzt_hours","getHours","jetzt_minutes","getMinutes","time_split","split","time_hours","parseInt","time_minutes","time_total_minutes","time_since_change","last_status_change_local","parse","time_since_change_vs_time_since_close","__exports__","IonHeader","IonToolbar","IonTitle","IonPage","LMap","LTileLayer","LMarker","populate_markers_array","loaded","markers","marker_objects","m","coordinates","c","parseFloat","modal","modalController","component","Modal","initialBreakpoint","breakpoints","username"],"sourceRoot":""}